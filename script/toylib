#!/usr/bin/env -S bash

# Command line interface for bundling Haskell source files into one file.

# npm install atcoder-cli
acc='npx acc'

# --------------------------------------------------------------------------------------------------
# Sub commands
# --------------------------------------------------------------------------------------------------

# $1: file name
_format() {
    ormolu --mode inplace "$1"
}

# $1: char
_submit() {
    cd "$1"
    $acc submit -s -- -y
    cd ../
}

# $1: char
_test_as_script() {
    oj t -N --directory "$1/test-cases" -c "$1"
}

# $1: char
_test_with_cabal() {
    # FIXME:
    # --ghc-options -DDEBUG
    cabal build "$1-exe"
    oj t -N --directory "$1/test-cases" -c "cabal run $1-exe"
}

# --------------------------------------------------------------------------------------------------
# Sub command dispatch
# --------------------------------------------------------------------------------------------------

_char_to_file_name() {
    printf '%s/Main.hs' "$1"
}

# In format `<problem> <command>`
_dispatch_sub_command() {
    local char="$1"
    local file="$(_char_to_file_name "$1")"
    shift 1

    local cmd="$1"
    shift 1

    case "$cmd" in
        'f' | 'fmt' | 'format')
            echo "formatting $file"
            _format "$file" "$@" ;;

        'r' | 'run')
            echo "running $file with cabal"
            _test_with_cabal "$char" "$@" ;;

        's' | 'submit')
            echo "submitting $file"
            _submit "$char" "$@" ;;

        't' | 'test')
            echo "testing $file"
            _test_as_script "$char" "$@" ;;

        *)
            echo "invalid input"

    esac
}

# --------------------------------------------------------------------------------------------------
# REPL
# --------------------------------------------------------------------------------------------------

_dispatch_repl_command() {
    if [ $# -eq 0 ] ; then
        return
    fi

    case "$1" in
        ':q' | ':quit')
            exit ;;

        *)
            _dispatch_sub_command "$@" ;;

    esac
}

_repl() {
    while true; do
        # readline
        IFS= read -e -p "> " line
        history -s "$line"

        _dispatch_repl_command $line
    done
}

# --------------------------------------------------------------------------------------------------
# Main
# --------------------------------------------------------------------------------------------------

_run() {
    if [ $# -eq 0 ] ; then
        _repl
        return
    fi

    _dispatch_sub_command "$@"
}

_run "$@"

