-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | For more info, see Github <a>https://github.com/toyboot4e/toy-lib</a>
@package toy-lib
@version 0.1.0.0

module Algorithm.TwoPointers

-- | Returns inclusive ranges that satisfy the given <tt>check</tt>. FIXME:
--   Use a simpler, cheaper implementation
twoPointers :: Int -> ((Int, Int) -> Bool) -> [(Int, Int)]


-- | Bit set tricks
module Data.BitSet

-- | Retrieves the most significant bit.
--   
--   <pre>
--   &gt;&gt;&gt; msbOf 0
--   -1
--   
--   &gt;&gt;&gt; msbOf maxBound
--   62
--   
--   &gt;&gt;&gt; msbOf $ 4 + 2 + 1
--   2
--   </pre>
msbOf :: Int -> Int

-- | Retrieves the least significant bit.
--   
--   <pre>
--   &gt;&gt;&gt; lsbOf 0
--   64
--   
--   &gt;&gt;&gt; lsbOf maxBound
--   0
--   
--   &gt;&gt;&gt; lsbOf $ 4 + 2 + 1
--   0
--   </pre>
lsbOf :: Int -> Int

-- | Originally by @yamate11
powersetM_ :: (Bits a, Num a, Monad m) => a -> (a -> m ()) -> m ()

-- | Originally by @yamate11
--   
--   <pre>
--   &gt;&gt;&gt; powerset (7 :: Int)
--   [7,6,5,4,3,2,1,0]
--   </pre>
powerset :: (Bits a, Num a) => a -> [a]

-- | Returns a powerset of <tt>x0</tt> in descending order.
--   
--   <pre>
--   &gt;&gt;&gt; powersetVU (7 :: Int)
--   [7,6,5,4,3,2,1,0]
--   </pre>
powersetVU :: (Bits a, Num a, Unbox a) => a -> Vector a


-- | <a>Data.Buffer</a> taken from <a>cojna/iota</a> (thanks!)
module Data.Buffer
data Buffer s a
Buffer :: !MVector s Int -> !MVector s a -> !Int -> Buffer s a
[bufferVars] :: Buffer s a -> !MVector s Int
[internalBuffer] :: Buffer s a -> !MVector s a
[internalBufferSize] :: Buffer s a -> !Int
_bufferFrontPos :: Int
_bufferBackPos :: Int
newBuffer :: (Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a)
type Stack s a = Buffer s a
newBufferAsStack :: (Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a)
type Queue s a = Buffer s a
newBufferAsQueue :: (Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a)
type Deque s a = Buffer s a
newBufferAsDeque :: (Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a)
lengthBuffer :: PrimMonad m => Buffer (PrimState m) a -> m Int
nullBuffer :: PrimMonad m => Buffer (PrimState m) a -> m Bool
clearBuffer :: PrimMonad m => Buffer (PrimState m) a -> m ()
freezeBuffer :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Vector a)
unsafeFreezeBuffer :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Vector a)
freezeInternalBuffer :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Vector a)
unsafeFreezeInternalBuffer :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Vector a)
popFront :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a)
viewFront :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a)
popBack :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a)
viewBack :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a)
pushFront :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ()
pushBack :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ()
pushFronts :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Vector a -> m ()
pushBacks :: (Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Vector a -> m ()


-- | Strongly connected components and topological sort.
module Data.Graph.Scc

-- | Topological sort implemented with postorder DFS.
--   
--   <h1>Implementation note</h1>
--   
--   Topological sort is for DAG, but internally it's used for <tt>scc</tt>
--   where cyclic graph input can come.
topSort :: Array Int [Int] -> [Int]

-- | Partial running of <tt>scc</tt> over topologically sorted vertices,
--   but for some connected components only.
topScc1 :: forall m. PrimMonad m => Array Int [Int] -> MVector (PrimState m) Bool -> Int -> m [Int]

-- | Retrieves a reverse graph
revGraph :: Array Int [Int] -> Array Int [Int]

-- | Collectes strongly connected components, topologically sorted.
--   Upstream vertices come first, e.g., <tt>(v1 - v2) -&gt; v3 -&gt;
--   v4</tt>.
topScc :: Array Int [Int] -> [[Int]]

-- | Collects cycles using <tt>scc</tt>.
topSccCycles :: Array Int [Int] -> [[Int]]

-- | Collectes strongly connected components, reverse topologically sorted.
--   Down stream vertices come first, e.g., <tt>v4 &lt;- v3 &lt;- (v2 -
--   v1)</tt>
downScc :: Array Int [Int] -> [[Int]]


-- | Multi set backed by <tt>IntMap</tt>.
module Data.MultiSet

-- | Multiset: (nKeys, (key -&gt; count))
type MultiSet = (Int, IntMap Int)
emptyMS :: MultiSet
singletonMS :: Int -> MultiSet
fromListMS :: [Int] -> MultiSet

-- | Increments key.
incMS :: Int -> MultiSet -> MultiSet

-- | Decrements key. Key with count zero are removed.
decMS :: Int -> MultiSet -> MultiSet
memberMS :: Int -> MultiSet -> Bool
notMemberMS :: Int -> MultiSet -> Bool
deleteFindMinMS :: MultiSet -> (Int, MultiSet)

-- | Unwraps <a>MultiSet</a> into the underlying <tt>IntMap</tt>.
innerMS :: MultiSet -> IntMap Int


-- | Helper methods for creating collections types from <tt>Vector</tt>
--   types.
module Data.FromVec
class FromVec a where {
    type FromVecInput a;
    type FromVecItem a;
}
fromVec :: (FromVec a, Vector v (FromVecInput a)) => v (FromVecInput a) -> a
fromVecWith :: (FromVec a, Vector v (FromVecInput a)) => (FromVecItem a -> FromVecItem a -> FromVecItem a) -> v (FromVecInput a) -> a

-- | Strongly typed <a>fromVec</a>.
fromVecIM :: Vector v (Int, a) => v (Int, a) -> IntMap a

-- | Strongly typed <a>fromVecWith</a>.
fromVecWithIM :: Vector v (Int, a) => (a -> a -> a) -> v (Int, a) -> IntMap a

-- | Strongly typed <a>fromVec</a>.
fromVecM :: (Vector v (k, a), Ord k) => v (k, a) -> Map k a

-- | Strongly typed <a>fromVecWith</a>.
fromVecWithM :: (Vector v (k, a), Ord k) => (a -> a -> a) -> v (k, a) -> Map k a

-- | Strongly typed <a>fromVec</a>.
fromVecIS :: Vector v Int => v Int -> IntSet

-- | Strongly typed <a>fromVec</a>.
fromVecS :: (Ord a, Vector v a) => v a -> Set a

-- | Strongly typed <a>fromVec</a>.
fromVecH :: (Ord a, Vector v a) => v a -> Heap a
instance Data.FromVec.FromVec (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Data.FromVec.FromVec (Data.Map.Internal.Map k a)
instance Data.FromVec.FromVec Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord a => Data.FromVec.FromVec (Data.Set.Internal.Set a)
instance GHC.Classes.Ord a => Data.FromVec.FromVec (Data.Heap.Heap a)
instance Data.FromVec.FromVec Data.MultiSet.MultiSet


-- | Dense, mutable multi set.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>ABC 315 D - Magical Cookies</a></li>
--   </ul>
module Data.MultiSetVec

-- | Dense, mutable multi set.
data MultiSetVec s
MultiSetVec :: MutVar s Int -> MVector s Int -> MultiSetVec s

-- | Monadic <a>show</a> over <a>MultiSetVec</a>.
showMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m String
newMSV :: PrimMonad m => Int -> m (MultiSetVec (PrimState m))
clearMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m ()
fromVecMSV :: PrimMonad m => Int -> Vector Int -> m (MultiSetVec (PrimState m))
countMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m Int
nullMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m Bool
readMSV :: PrimMonad m => MultiSetVec (PrimState m) -> Int -> m Int
incMSV :: PrimMonad m => MultiSetVec (PrimState m) -> Int -> m ()
decMSV :: PrimMonad m => MultiSetVec (PrimState m) -> Int -> m ()

-- | $O(n)$ Find minimum key element
minMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m (Maybe (Int, Int))

-- | $O(n)$ Find maximum key element
maxMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m (Maybe (Int, Int))
unsafeFreezeMSV :: PrimMonad m => MultiSetVec (PrimState m) -> m (Int, Vector Int)

module Data.SafeList

-- | Safelist
class SafeList v where {
    type SafeListElem v;
}
headMay :: SafeList v => v -> Maybe (SafeListElem v)
lastMay :: SafeList v => v -> Maybe (SafeListElem v)
headOr :: SafeList v => SafeListElem v -> v -> SafeListElem v
lastOr :: SafeList v => SafeListElem v -> v -> SafeListElem v
minimumMay :: SafeList v => v -> Maybe (SafeListElem v)
maximumMay :: SafeList v => v -> Maybe (SafeListElem v)
minimumOr :: SafeList v => SafeListElem v -> v -> SafeListElem v
maximumOr :: SafeList v => SafeListElem v -> v -> SafeListElem v
instance GHC.Classes.Ord a => Data.SafeList.SafeList [a]
instance GHC.Classes.Ord a => Data.SafeList.SafeList (Data.Vector.Vector a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a) => Data.SafeList.SafeList (Data.Vector.Unboxed.Base.Vector a)

module Data.SegmentTree.Strict

-- | A mutable segment tree backed by a complete binary tree.
--   
--   <h1>Overview</h1>
--   
--   A segment tree is a cache of a folding function. Each node corresponds
--   to a folding range and the node contains the folding result.
--   
--   A segment tree has a constant size and never be resized.
--   
--   <h1>Operations</h1>
--   
--   Modification takes &lt;math&gt;, so creation takes &lt;math&gt;.
--   Lookup takes &lt;math&gt;.
--   
--   <h1>(Internal) Indices</h1>
--   
--   The complete binary tree has <tt>2 ^ depth - 1</tt> elements.
--   
--   <ul>
--   <li>Child elements of a parent node <tt>i</tt> has index <tt>2 * i +
--   1</tt> and <tt>2 * i + 2</tt>.</li>
--   <li>The leaf indices start with <tt>length / 2 - 1</tt>.</li>
--   </ul>
--   
--   Example:
--   
--   <pre>
--              0
--        1           2
--     3     4     5     6
--   07 08 09 10 11 12 13 14
--   </pre>
data SegmentTree v s a
SegmentTree :: (a -> a -> a) -> v s a -> SegmentTree v s a

-- | Creates a new segment tree for <tt>n</tt> leaves. REMARK: Always give
--   a zero value. It fills all the nodes including parent nodes, and the
--   parent nodes are not updated.
newSTreeVG :: (MVector v a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree v (PrimState m) a)

-- | Creates a boxed segment tree.
newSTreeV :: PrimMonad m => (a -> a -> a) -> Int -> a -> m (SegmentTree MVector (PrimState m) a)

-- | Creates an unboxed segment tree.
newSTreeVU :: (Unbox a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree MVector (PrimState m) a)

-- | Sets all the internal values of a segment tree to the given value
--   which has to be zero.
--   
--   REMARK: It takes lots of time. Consider a much more efficient
--   resettiong strategy such as re-inserting zeros to used slots, or maybe
--   use | <tt>compressInvNumVG</tt> when you just need inversion number.
resetSTree :: (MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> a -> m ()

-- | Updates an <a>SegmentTree</a> leaf value and their parents up to top
--   root.
insertSTree :: (MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ()

-- | Updates an <a>SegmentTree</a> leaf value and their parents up to top
--   root.
modifySTree :: (MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> (a -> a) -> Int -> m ()

-- | (Internal) Updates an <a>SegmentTree</a> element (node or leaf) value
--   and their parents up to top root. REMARK: It's faster to not INLINE
--   the recursive function:
_updateElement :: (MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ()

-- | Retrieves the folding result over the inclusive range `[l, r]` from
--   <a>SegmentTree</a>.
querySTree :: forall v a m. (MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> (Int, Int) -> m (Maybe a)


-- | <a>Semiring</a>
module Data.Semiring

-- | Semiring @(s, <a>+</a>, <a>.</a>)`. Sometimes called "deoid" (double
--   monoid).
class Semiring s

-- | Plus (addition) opeator of the communicative monoid <tt>(s, <a>+</a>,
--   szero)</tt>.
(<+>) :: Semiring s => s -> s -> s

-- | Identical element of the communicative monoid <tt>(s, <a>+</a>,
--   szero)</tt>.
szero :: Semiring s => s

-- | Times (mulitplication) operator of the monoid <tt>(s, <a>.</a>,
--   sone)</tt>.
(<.>) :: Semiring s => s -> s -> s

-- | Identical element of the monoid <tt>(s, <a>.</a>, sone)</tt>
sone :: Semiring s => s

-- | Fold using the <a>&lt;+&gt;</a> (plus) opreator.
foldP :: (Semiring a, Vector v a) => v a -> a

-- | Fold using the <a>&lt;.&gt;</a> (times) opreator.
foldT :: (Semiring a, Vector v a) => v a -> a

-- | Max-Plus semiring
newtype MaxPlus a
MaxPlus :: a -> MaxPlus a
[getMaxPlus] :: MaxPlus a -> a

-- | Min-Plus semiring
newtype MinPlus a
MinPlus :: a -> MinPlus a
[getMinPlus] :: MinPlus a -> a

-- | Boolean semiring
newtype Boolean
Boolean :: Bool -> Boolean
[getBoolean] :: Boolean -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Data.Semiring.MaxPlus a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semiring.MaxPlus a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semiring.MaxPlus a)
instance Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semiring.MaxPlus a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semiring.MinPlus a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semiring.MinPlus a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semiring.MinPlus a)
instance Data.Primitive.Types.Prim a => Data.Primitive.Types.Prim (Data.Semiring.MinPlus a)
instance GHC.Show.Show Data.Semiring.Boolean
instance GHC.Classes.Ord Data.Semiring.Boolean
instance GHC.Classes.Eq Data.Semiring.Boolean
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semiring.MaxPlus a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semiring.MaxPlus a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.Semiring.MinPlus a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.Semiring.MinPlus a)
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Data.Semiring.Boolean
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Data.Semiring.Boolean
instance Data.Vector.Unboxed.Base.IsoUnbox Data.Semiring.Boolean GHC.Types.Bool
instance Data.Vector.Unboxed.Base.Unbox Data.Semiring.Boolean
instance Data.Semiring.Semiring Data.Semiring.Boolean
instance Data.Primitive.Types.Prim a => Data.Vector.Unboxed.Base.Unbox (Data.Semiring.MinPlus a)
instance (GHC.Num.Num a, GHC.Enum.Bounded a, GHC.Classes.Ord a) => Data.Semiring.Semiring (Data.Semiring.MinPlus a)
instance Data.Primitive.Types.Prim a => Data.Vector.Unboxed.Base.Unbox (Data.Semiring.MaxPlus a)
instance (GHC.Num.Num a, GHC.Enum.Bounded a, GHC.Classes.Ord a) => Data.Semiring.Semiring (Data.Semiring.MaxPlus a)


-- | Alias to `(Int, [Int])`
module Data.SizedList

-- | `(length, digitsInDescendingOrder)`
type SizedList = (Int, [Int])
compareSL :: SizedList -> SizedList -> Ordering
maxSL :: SizedList -> SizedList -> SizedList
nullSL :: SizedList -> Bool
emptySL :: SizedList
consSL :: SizedList -> Int -> SizedList


-- | Union-find tree
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 012 - Red Painting (★4)</a></li>
--   </ul>
module Data.UnionFind.Mutable

-- | Dense, mutable union-find tree (originally by `@pel`)
--   
--   <pre>
--   &gt;&gt;&gt; stree &lt;- newMUF 3
--   
--   &gt;&gt;&gt; sameMUF stree 0 2
--   False
--   
--   &gt;&gt;&gt; uniteMUF stree 0 2
--   True
--   
--   &gt;&gt;&gt; sameMUF stree 0 2
--   True
--   
--   &gt;&gt;&gt; uniteMUF stree 0 2
--   False
--   </pre>
newtype MUnionFind s
MUnionFind :: MVector s MUFNode -> MUnionFind s
type IOUnionFind = MUnionFind RealWorld
type STUnionFind s = MUnionFind s

-- | `MUFChild parent | MUFRoot size`.
data MUFNode
MUFChild :: {-# UNPACK #-} !Int -> MUFNode
MUFRoot :: {-# UNPACK #-} !Int -> MUFNode

-- | Creates a new Union-Find tree of the given size.
newMUF :: PrimMonad m => Int -> m (MUnionFind (PrimState m))

-- | Returns the root node index.
rootMUF :: PrimMonad m => MUnionFind (PrimState m) -> Int -> m Int

-- | Returns all root vertices.
groupsMUF :: PrimMonad m => MUnionFind (PrimState m) -> m IntSet

-- | Checks if the two nodes are under the same root.
sameMUF :: PrimMonad m => MUnionFind (PrimState m) -> Int -> Int -> m Bool

-- | Just an internal helper.
_unwrapMUFRoot :: MUFNode -> Int

-- | Unites two nodes. Returns <a>True</a> when thry're newly united.
uniteMUF :: PrimMonad m => MUnionFind (PrimState m) -> Int -> Int -> m Bool

-- | Returns the size of the a node, starting with `1`.
sizeMUF :: PrimMonad m => MUnionFind (PrimState m) -> Int -> m Int
clearMUF :: PrimMonad m => MUnionFind (PrimState m) -> m ()
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Data.UnionFind.Mutable.MUFNode
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Data.UnionFind.Mutable.MUFNode
instance Data.Vector.Unboxed.Base.IsoUnbox Data.UnionFind.Mutable.MUFNode (GHC.Types.Bool, GHC.Types.Int)
instance Data.Vector.Unboxed.Base.Unbox Data.UnionFind.Mutable.MUFNode

module Data.UnionFind.Sparse
type SparseUnionFind = IntMap Int
newSUF :: SparseUnionFind
fromListSUF :: [(Int, Int)] -> SparseUnionFind
rootSUF :: SparseUnionFind -> Int -> (Int, Int)
sameSUF :: SparseUnionFind -> Int -> Int -> Bool
uniteSUF :: SparseUnionFind -> Int -> Int -> SparseUnionFind


-- | Obsolute. TODO: Delete.
module Math.Bits

-- | Log base of two or bit floor.
--   <a>https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Bits.html#v:countLeadingZeros</a>
log2 :: FiniteBits b => b -> Int

-- | Ceiling of log base 2 of an <a>Int</a>.
--   
--   <h1>Example</h1>
--   
--   <pre>
--   &gt; log2 3
--   1
--   &gt; log2CeilInt 3
--   2
--   </pre>
log2CeilInt :: Int -> Int

-- | Calculates the smallest integral power of two that is not smaller than
--   <tt>x</tt>.
--   
--   <h1>Example</h1>
--   
--   <pre>
--   &gt; bitCeil 3
--   4
--   </pre>
bitCeil :: Int -> Int


-- | Obsolute. TODO: Delete.
module Math.Digits

-- | Returns the digits of a positive integer as a Maybe list, in reverse
--   order or Nothing if a zero or negative base is given. This is slightly
--   more efficient than in forward order.
mDigitsRev :: Integral n => n -> n -> Maybe [n]

-- | Returns the digits of a positive integer as a Maybe list. or Nothing
--   if a zero or negative base is given
mDigits :: Integral n => n -> n -> Maybe [n]

-- | Returns the digits of a positive integer as a list, in reverse order.
--   Throws an error if given a zero or negative base.
digitsRev :: Integral n => n -> n -> [n]

-- | Returns the digits of a positive integer as a list. REMARK: It's
--   modified to return `[0]` when given zero.
digits :: Integral n => n -> n -> [n]

-- | Takes a list of digits, and converts them back into a positive
--   integer.
unDigits :: Integral n => n -> [n] -> n

-- | 
--   <a>https://stackoverflow.com/questions/10028213/converting-number-base</a>
--   REMARK: It returns `[]` when given `[0]`. Be sure to convert `[]` to
--   `[0]` if necessary.
convertBase :: Integral a => a -> a -> [a] -> [a]


-- | Digits by <tt>Vector</tt>
module Math.DigitsVector

-- | <pre>
--   &gt;&gt;&gt; toDigitsVU 3 ((3^0)*1 + (3^1)*2 + (3^2)*1)
--   [1,2,1]
--   </pre>
toDigitsVU :: Int -> Int -> Vector Int

-- | <pre>
--   &gt;&gt;&gt; toNDigitsVU 3 3 ((3^0)*1 + (3^1)*0 + (3^2)*0)
--   [1,0,0]
--   </pre>
toNDigitsVU :: Int -> Int -> Int -> Vector Int

-- | <pre>
--   &gt;&gt;&gt; unDigitsVU 3 (VU.fromList [1,2,1]) == ((3^0)*1 + (3^1)*2 + (3^2)*1)
--   True
--   
--   &gt;&gt;&gt; unDigitsVU 3 (toDigitsVU 3 ((3^0)*1 + (3^1)*2 + (3^2)*1)) == ((3^0)*1 + (3^1)*2 + (3^2)*1)
--   True
--   </pre>
unDigitsVU :: Int -> Vector Int -> Int


-- | The number of divisor is smaller than &lt;math&gt;. See also:
--   <a>https://scrapbox.io/magurofly/%E7%B4%84%E6%95%B0%E3%81%AE%E5%80%8B%E6%95%B0%E3%81%AE%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC</a>
--   
--   <h1>Tips</h1>
--   
--   <ul>
--   <li>The last number could be decided with division, not
--   enumeration.</li>
--   </ul>
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 085 - Multiplication (★4)</a></li>
--   <li><a>ABC 300 D - AABBC (Difficulty 908)</a></li>
--   </ul>
--   
--   <h1>Prime factors</h1>
--   
--   <ul>
--   <li><a>Typical 030 - K Factors (★5)</a> Numbers with i &gt;= k prime
--   factors can be enumerated very fastly.</li>
--   </ul>
--   
--   <h1>Split and list / meet in the middle</h1>
--   
--   <ul>
--   <li><a>Typical 051 - Typical Shop (★5)</a></li>
--   </ul>
--   
--   <h1>Other problems</h1>
--   
--   <ul>
--   <li><a>ABC 254 D - Together Square (Difficulty 1191)</a></li>
--   </ul>
module Math.Divisors
divisorsOf :: Int -> [Int]


-- | Extended Eucried Algorithm
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>ABC 186 E - Throne</a></li>
--   </ul>
--   
--   <h1>Related</h1>
--   
--   <ul>
--   <li><a>Water drawing problem</a></li>
--   </ul>
module Math.Exgcd

-- | @4tsuzuru <a>https://zenn.dev/link/comments/29d659a57ead56</a>
--   
--   <tt>exgcd a b</tt> returns <tt>(g, na, nb)</tt> where &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; exgcd 3 5
--   (1,2,-1)
--   
--   &gt;&gt;&gt; 1 == 3 * 2 + 5 * (-1)
--   True
--   </pre>
--   
--   Note that &lt;math&gt;: &lt;math&gt;
exgcd :: Integral a => a -> a -> (a, a, a)

-- | Example for showing how to use <a>exgcd</a> to calculate the modular
--   multicative inverse.
invModGcd :: Integral a => a -> a -> Maybe a


-- | Manhattan distance
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 036 - Max Manhattan Distance (★5)</a></li>
--   <li><a>Typical 070 - Plant Planning (★4)</a></li>
--   </ul>
module Math.Manhattan

-- | Rotates <tt>(x, y)</tt> pair in 45 degree and scales &lt;math&gt;.
--   Note that <tt>x</tt> comes first in the pair.
--   
--   2D Manhattan distance is definned as &lt;math&gt;. After this
--   transformation, it's calculated with &lt;math&gt;.
--   
--   This transformation applies &lt;math&gt;, but without the cofficient.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 036 - Max Manhattan Distance (★5)</a></li>
--   </ul>
rot45 :: (Int, Int) -> (Int, Int)


-- | Prime number enumeration and prime factorization.
module Math.Primes

-- | @0xYusuke <a>https://zenn.dev/link/comments/1022553732563c</a>
primes :: [Int]

-- | Returns <tt>[(prime, count)]</tt>
primeFactors :: Int -> [(Int, Int)]

module ToyLib.Macro
dbg :: Show a => a -> ()
dbgId :: Show a => a -> a
note :: (Show s, Show a) => s -> a -> a
dbgAssert :: Bool -> a -> a


-- | Semigroup action <tt>*</tt> is an operator where &lt;math&gt; holds.
module Data.SemigroupAction

-- | Right semigroup aciton.
class SemigroupAction s a

-- | Right semigroup aciton
sact :: SemigroupAction s a => s -> a -> a

-- | Right monoid action.
class (SemigroupAction m a, Monoid m) => MonoidAction m a

-- | Right monoid aciton
mact :: MonoidAction m a => m -> a -> a

-- | Permutation of N sequence.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 058 - Original Calculator (★4)</a></li>
--   </ul>
newtype Permutation
Permutation :: Vector Int -> Permutation
instance GHC.Classes.Eq Data.SemigroupAction.Permutation
instance GHC.Show.Show Data.SemigroupAction.Permutation
instance GHC.Base.Semigroup Data.SemigroupAction.Permutation
instance Data.SemigroupAction.SemigroupAction Data.SemigroupAction.Permutation GHC.Types.Int
instance Data.SemigroupAction.SemigroupAction (Data.Semigroup.Internal.Product GHC.Types.Int) GHC.Types.Int

module ToyLib.Prelude

-- | From more recent GHC
clamp :: Ord a => (a, a) -> a -> a
flipOrder :: Ordering -> Ordering
square :: Num a => a -> a
modifyArray :: (MArray a e m, Ix i) => a i e -> (e -> e) -> i -> m ()

-- | Two-variable function compositon.
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c

-- | Three-variable function compositon.
(.:.) :: (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c

-- | Strict funciton composition.
(.!) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .!
foldFor :: Foldable t => b -> t a -> (b -> a -> b) -> b
foldForVG :: Vector v a => b -> v a -> (b -> a -> b) -> b
foldForM :: (Foldable t, Monad m) => b -> t a -> (b -> a -> m b) -> m b
foldForMVG :: (PrimMonad m, Vector v a) => b -> v a -> (b -> a -> m b) -> m b
foldForMMS :: Monad m => a -> Stream m b -> (a -> b -> m a) -> m a

-- | <h1>Test</h1>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOfVG 3 $ VU.fromList ([1, 2, 3, 4, 5, 6, 7] :: [Int])
--   [[1,2,3],[4,5,6],[7]]
--   </pre>
chunksOfVG :: Vector v a => Int -> v a -> Vector (v a)
swapDupeVU :: Vector (Int, Int) -> Vector (Int, Int)

-- | List-like range syntax for <tt>vector</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; rangeVG @VU.Vector 3 5
--   [3,4,5]
--   </pre>
rangeVG :: Vector v Int => Int -> Int -> v Int

-- | Type-constrained <a>rangeVG</a>.
rangeV :: Int -> Int -> Vector Int

-- | Type-constrained <a>rangeVG</a>.
rangeVU :: Int -> Int -> Vector Int

-- | Easier reverse range syntax for <tt>vector</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; rangeVGR @VU.Vector 3 5
--   [5,4,3]
--   </pre>
rangeVGR :: Vector v Int => Int -> Int -> v Int

-- | Type-constrained <a>rangeVGR</a>.
rangeVR :: Int -> Int -> Vector Int

-- | Type-constrained <a>rangeVGR</a>.
rangeVUR :: Int -> Int -> Vector Int

-- | @cojna (<tt>stream</tt>)
rangeMS :: Monad m => Int -> Int -> Stream m Int

-- | @cojna (<tt>streamR</tt>)
rangeMSR :: Monad m => Int -> Int -> Stream m Int

-- | <a>forM</a> over monadic stream in the vector package. | NOTE: This is
--   for side effects only. I don't know how to use <a>mapM</a> yet.
forMS_ :: Monad m => Stream m Int -> (Int -> m ()) -> m ()
repM_ :: Monad m => Int -> Int -> (Int -> m ()) -> m ()
repRM_ :: Monad m => Int -> Int -> (Int -> m ()) -> m ()

-- | <tt>constructN</tt> with initial value for index zero.
constructN0 :: Unbox a => a -> Int -> (Vector a -> a) -> Vector a
compress :: Eq a => [a] -> [a]

-- | Runs the given function <tt>n</tt> times.
times :: Int -> (a -> a) -> a -> a

-- | Combinations. - <a>https://stackoverflow.com/a/58511843</a> -
--   <a>https://zenn.dev/osushi0x/scraps/51ff0594a1e863#comment-e6b0af9b61c54c</a>
combs :: Int -> [a] -> [[a]]
swapDupe :: (a, a) -> ((a, a), (a, a))
add2 :: (Int, Int) -> (Int, Int) -> (Int, Int)
sub2 :: (Int, Int) -> (Int, Int) -> (Int, Int)
mul2 :: Int -> (Int, Int) -> (Int, Int)
add3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
sub3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
mul3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int)
toRadian :: Double -> Double
toDegree :: Double -> Double
fst4 :: (a, b, c, d) -> a
snd4 :: (a, b, c, d) -> b
thd4 :: (a, b, c, d) -> c
fth4 :: (a, b, c, d) -> d
traceMat2D :: (IArray a e, Ix i, Show e) => a (i, i) e -> ()
traceSubMat2D :: (IArray a e, Ix i, Show e) => a (i, i) e -> ((i, i), (i, i)) -> ()

-- | Inaccurate, but fast <a>Int</a> square root. TODO: Fast and accurate
--   implementation
isqrt :: Int -> Int


-- | Handy, more restricted <a>Ix</a> with reverse conversion, fast monadic
--   iteration and unboxing.
module Data.Unindex
class RangeMS a
rangeMS2 :: (RangeMS a, Monad m) => (a, a) -> Stream m a
class (Ix i, Unbox i) => Unindex i
unindex :: Unindex i => (i, i) -> Int -> i
instance Data.Unindex.Unindex GHC.Types.Int
instance Data.Unindex.Unindex (GHC.Types.Int, GHC.Types.Int)
instance Data.Unindex.Unindex (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
instance Data.Unindex.RangeMS GHC.Types.Int
instance Data.Unindex.RangeMS (GHC.Types.Int, GHC.Types.Int)


-- | <a>Ix</a>-based API over <tt>vector</tt>.
module Data.Vector.IxVector

-- | N-dimensional <tt>Vector</tt> or <tt>MVector</tt> with <a>Ix</a>.
data IxVector i v
IxVector :: !(i, i) -> !v -> IxVector i v
[boundsIV] :: IxVector i v -> !(i, i)
[vecIV] :: IxVector i v -> !v

-- | Primary <a>IxVector</a> type notation.
type IxUVector i a = IxVector i (Vector a)

-- | Primary <a>IxVector</a> type notation.
type IxMUVector i s a = IxVector i (MVector s a)

-- | Partial <a>IxVector</a> accessor
(@!) :: (Ix i, Vector v a) => IxVector i (v a) -> i -> a

-- | Partial unsafe <a>IxVector</a> accessor
(@!!) :: (Ix i, Vector v a) => IxVector i (v a) -> i -> a

-- | Total <a>IxVector</a> accessor
(@!?) :: (Ix i, Vector v a) => IxVector i (v a) -> i -> Maybe a

-- | Total unsafe <a>IxVector</a> accessor
(@!!?) :: (Ix i, Vector v a) => IxVector i (v a) -> i -> Maybe a
mapIV :: (Unbox a, Unbox b) => (a -> b) -> IxVector i (Vector a) -> IxVector i (Vector b)
imapIV :: (Unindex i, Unbox a, Unbox b) => (i -> a -> b) -> IxVector i (Vector a) -> IxVector i (Vector b)
zipWithIV :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> IxVector i (Vector a) -> IxVector i (Vector b) -> IxVector i (Vector c)

-- | Altertnative to <tt>accumulate</tt> for <a>IxVector</a> that share the
--   same bounds.
accumulateIV :: (Ix i, Unbox i, Unbox a, Unbox b) => (a -> b -> a) -> IxVector i (Vector a) -> IxVector i (Vector (i, b)) -> IxVector i (Vector a)

-- | Reads a value from <a>IxVector</a>.
readIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a
unsafeReadIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a

-- | Writes a value to <a>IxVector</a>.
writeIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ()
unsafeWriteIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ()
modifyIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ()
unsafeModifyIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ()
modifyMIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ()
unsafeModifyMIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ()
swapIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ()
unsafeSwapIV :: (Ix i, PrimMonad m, MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ()

-- | WARNING: Can you really allocate/run &lt;math&gt; algorithm?
imos2DIV :: IxVector (Int, Int) (Vector Int) -> IxVector (Int, Int) (Vector Int)
instance (GHC.Classes.Eq i, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.Vector.IxVector.IxVector i v)
instance (GHC.Show.Show i, GHC.Show.Show v) => GHC.Show.Show (Data.Vector.IxVector.IxVector i v)


-- | Super dirty slow IO
--   
--   <h1>Main procedures</h1>
--   
--   <a>ints2</a>, <a>intsW</a>, <a>get</a>, <a>digitsVU</a>,
--   <a>getGrid</a> and <a>charsH</a>.
--   
--   <h1><a>ReadBS</a> and <a>get</a></h1>
--   
--   Primitives are <a>ReadBS</a>. Tuples of <a>ReadBS</a> are also
--   <a>ReadBS</a>:
--   
--   <pre>
--   &gt;&gt;&gt; convertBS @(Int, Char, String, Float) $ BS.pack "42 c string 2.5"
--   (42,'c',"string",2.5)
--   </pre>
--   
--   Vectors are <a>ReadBS</a> and they can also be embedded in the end of
--   a tuple:
--   
--   <pre>
--   &gt;&gt;&gt; convertBS $ BS.pack "1 string 3.5 10 20 30 40" :: (Int, String, Float, VU.Vector Int)
--   (1,"string",3.5,[10,20,30,40])
--   </pre>
module ToyLib.IO
int :: IO Int

-- | Reads one line as a list of integers.
ints :: IO [Int]

-- | Read from a space-delimited <tt>ByteStrtig</tt>.
class ReadBS a
convertBS :: ReadBS a => ByteString -> a
convertBS :: (ReadBS a, Read a) => ByteString -> a

-- | For use with <a>unfoldrExactN</a>.
readBS :: ReadBS a => ByteString -> (a, ByteString)

-- | For use with <a>unfoldr</a>.
readMayBS :: ReadBS a => ByteString -> Maybe (a, ByteString)

-- | Converrts the given <tt>ByteString</tt> as a vector of <tt>a</tt>.
convertVG :: (ReadBS a, Vector v a) => ByteString -> v a

-- | Converts the given <tt>ByteString</tt> as a vector of <tt>a</tt> with
--   <tt>n</tt> elements.
convertNVG :: (ReadBS a, Vector v a) => Int -> ByteString -> v a
get :: ReadBS a => IO a
ints1 :: IO Int
ints2 :: IO (Int, Int)
ints3 :: IO (Int, Int, Int)
ints4 :: IO (Int, Int, Int, Int)
ints5 :: IO (Int, Int, Int, Int, Int)
ints6 :: IO (Int, Int, Int, Int, Int, Int)
intsW :: Vector v Int => Int -> IO (v Int)

-- | Reads one line as an integer.
intsVG :: Vector v Int => IO (v Int)
intsV :: IO (Vector Int)

-- | Reads one line as a vector of integers.
intsVU :: IO (Vector Int)
digitsVU :: IO (Vector Int)
intsRestVG :: Vector v Int => IO (v Int)
intsRestVU :: IO (Vector Int)

-- | Creates a graph from 1-based vertices
getGraph :: Int -> Int -> IO (Array Int [Int])

-- | Converts <tt>n</tt> lines of **whitespace-delimited
--   <tt>ByteString</tt>** into a flat vector of type <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; convertNBS @Int (3 * 3) $ V.map BS.pack $ V.fromList ["1 2 3", "4 5 6", "7 8 9"]
--   [1,2,3,4,5,6,7,8,9]
--   </pre>
convertNBS :: forall a. (Unbox a, ReadBS a) => Int -> Vector ByteString -> Vector a

-- | Reads <tt>h</tt> lines of stdin and converts them as HxW
--   **whitespace-delimited <tt>ByteString</tt>** and converts them into a
--   flat vector of type <tt>a</tt>.
getHW :: (Unbox a, ReadBS a) => Int -> Int -> IO (Vector a)

-- | Reads <tt>h</tt> lines of stdin and converts them into a IxVector
--   reading as HxW **whitespace-separated** input.
getGrid :: Int -> Int -> IO (IxVector (Int, Int) (Vector Int))

-- | Converts @n` lines of <tt>ByteString</tt> into a flat vector.
--   
--   <pre>
--   &gt;&gt;&gt; VU.map (== '#') . convertCharsHW $ V.map BS.pack $ V.fromList ["#.#", ".#."]
--   [True,False,True,False,True,False]
--   </pre>
convertCharsHW :: Vector ByteString -> Vector Char

-- | See <a>convertCharsHW</a>.
charsH :: Int -> IO (Vector Char)

-- | <a>concat</a> two-item tuples
concat2 :: [(a, a)] -> [a]
concatMap2 :: (a -> (b, b)) -> [a] -> [b]

-- | Creates a weightend graph from 1-based vertices
getWGraph :: Int -> Int -> IO (Array Int [Entry Int Int])

-- | Creates a weightend graph from 1-based vertices
getWGraph0 :: Int -> Int -> IO (Array Int [Entry Int Int])
endlBSB :: Builder
putBSB :: Builder -> IO ()
putLnBSB :: Builder -> IO ()

-- | Show as a bytestring builder.
class ShowBSB a
showBSB :: ShowBSB a => a -> Builder
showBSB :: (ShowBSB a, Show a) => a -> Builder
showLnBSB :: ShowBSB a => a -> Builder
printBSB :: ShowBSB a => a -> IO ()

-- | See <a>unwordsBSB</a> as example.
concatBSB :: Vector v a => (a -> Builder) -> v a -> Builder
unwordsBSB :: (ShowBSB a, Vector v a) => v a -> Builder
unlinesBSB :: (ShowBSB a, Vector v a) => v a -> Builder
yn :: Bool -> String
ynBSB :: Bool -> Builder
printYn :: Bool -> IO ()
instance ToyLib.IO.ShowBSB GHC.Types.Int
instance ToyLib.IO.ShowBSB GHC.Num.Integer.Integer
instance ToyLib.IO.ShowBSB GHC.Types.Float
instance ToyLib.IO.ShowBSB GHC.Types.Double
instance ToyLib.IO.ReadBS GHC.Types.Int
instance ToyLib.IO.ReadBS GHC.Num.Integer.Integer
instance ToyLib.IO.ReadBS GHC.Types.Float
instance ToyLib.IO.ReadBS GHC.Types.Double
instance ToyLib.IO.ReadBS GHC.Types.Char
instance ToyLib.IO.ReadBS GHC.Base.String
instance ToyLib.IO.ReadBS Data.ByteString.Internal.Type.ByteString
instance (ToyLib.IO.ReadBS a, Data.Vector.Unboxed.Base.Unbox a) => ToyLib.IO.ReadBS (Data.Vector.Unboxed.Base.Vector a)
instance ToyLib.IO.ReadBS a => ToyLib.IO.ReadBS (Data.Vector.Vector a)
instance (ToyLib.IO.ReadBS a1, ToyLib.IO.ReadBS a2) => ToyLib.IO.ReadBS (a1, a2)
instance (ToyLib.IO.ReadBS a1, ToyLib.IO.ReadBS a2, ToyLib.IO.ReadBS a3) => ToyLib.IO.ReadBS (a1, a2, a3)
instance (ToyLib.IO.ReadBS a1, ToyLib.IO.ReadBS a2, ToyLib.IO.ReadBS a3, ToyLib.IO.ReadBS a4) => ToyLib.IO.ReadBS (a1, a2, a3, a4)
instance (ToyLib.IO.ReadBS a1, ToyLib.IO.ReadBS a2, ToyLib.IO.ReadBS a3, ToyLib.IO.ReadBS a4, ToyLib.IO.ReadBS a5) => ToyLib.IO.ReadBS (a1, a2, a3, a4, a5)
instance (ToyLib.IO.ReadBS a1, ToyLib.IO.ReadBS a2, ToyLib.IO.ReadBS a3, ToyLib.IO.ReadBS a4, ToyLib.IO.ReadBS a5, ToyLib.IO.ReadBS a6) => ToyLib.IO.ReadBS (a1, a2, a3, a4, a5, a6)


-- | Debug utilities
module ToyLib.Debug

-- | For use with <tt>dbgS</tt>
class ShowGrid a
showGrid :: ShowGrid a => a -> String

-- | <a>$</a> with <a>dbgId</a>
($$) :: Show a => (a -> b) -> a -> b
infixr 0 $$

-- | <a>.</a> with <a>dbgId</a>
(.$) :: Show b => (b -> c) -> (a -> b) -> a -> c
infixr 9 .$
instance (Data.Vector.Generic.Base.Vector v a, GHC.Show.Show a) => ToyLib.Debug.ShowGrid (Data.Vector.IxVector.IxVector (GHC.Types.Int, GHC.Types.Int) (v a))


-- | Typical DP utilities
--   
--   TODO: Refactor <a>relaxMany</a> variants.
module ToyLib.DP

-- | Variant of <a>constructN</a>.
constructFor :: (Unbox a, Unbox b) => a -> Vector b -> (Vector a -> b -> a) -> Vector a

-- | <tt>accumulate</tt> variant with <a>concatMap</a>-like expander. Be
--   wanrned that *the <tt>input</tt> is consumed in-place*. Run like
--   <tt>relaxMany vec0 (VU.force vec0) $ x -&gt; ..</tt> if it needs to be
--   cloned.
--   
--   <tt>relaxMany !f !vec0 !input !expander</tt> ~ <tt>VG.accumulate f
--   vec0 $ VG.concatMap expander input</tt>
relaxMany :: (Vector v a, Vector v (Int, a), Vector v b) => (a -> a -> a) -> v a -> v b -> (b -> v (Int, a)) -> v a

-- | <a>relaxMany</a> with index input. Be wanrned that *the <tt>input</tt>
--   is consumed in-place*. Run like <tt>relaxMany vec0 (VU.force vec0) $ x
--   -&gt; ..</tt> if it needs to be cloned.
irelaxMany :: (Vector v a, Vector v (Int, a), Vector v b) => (a -> a -> a) -> v a -> v b -> (Int -> b -> v (Int, a)) -> v a

-- | Monoid variant of <a>relaxMany</a>
relaxMany' :: (Monoid m, Unbox m, Unbox a) => Vector m -> Vector a -> (a -> Vector (Int, m)) -> Vector m
pushBasedConstructN :: (Vector v a, Vector v (Int, a)) => (a -> a -> a) -> v a -> (Int -> v a -> v (Int, a)) -> v a

-- | Returns non-zero two spans over the given inclusive range <tt>[l,
--   r]</tt>. &gt;&gt;&gt; spansVU 3 6
--   [((3,3),(4,6)),((3,4),(5,6)),((3,5),(6,6))]
spansVU :: Int -> Int -> Vector ((Int, Int), (Int, Int))

-- | <a>constructN</a> for <a>IxVector</a>
constructIV :: (Unindex i, Unbox a) => (i, i) -> (IxVector i (Vector a) -> i -> a) -> IxVector i (Vector a)

-- | Span-based DP with preset index patterns.
spanDP :: Unbox a => Int -> a -> (Int -> a) -> (IxVector (Int, Int) (Vector a) -> (Int, Int) -> a) -> IxVector (Int, Int) (Vector a)

-- | Typical set-based DP.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>ABC 317 C - Remembering the Days</a></li>
--   </ul>
tspDP :: Int -> IxUVector (Int, Int) Int -> Vector Int

-- | Enumerates all possible bitsets that composes <tt>bit n - 1</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; enumerateBitSets 4
--   [[8,4,2,1],[12,2,1],[8,6,1],[4,10,1],[14,1],[8,4,3],[12,3],[8,2,5],[10,5],[8,7],[4,2,9],[6,9],[4,11],[2,13],[15],[]]
--   </pre>
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>ABC 310 D - Peaceful Teams</a></li>
--   <li><a>ABC 319 D - General Weighted Max Matching</a> (Not the exact
--   pattern though)</li>
--   </ul>
enumerateBitSets :: Int -> [[Int]]

-- | The input must be one-based
lcs :: Vector Int -> Int


-- | 01-BFS
module ToyLib.BFS01
bfs01_grid4_typical043 :: IxUVector (Int, Int) Bool -> (Int, Int) -> IxUVector (Int, Int, Int) Int


-- | Lazy segment tree, where we can perform operation over range.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 029 - Long Bricks (★5)</a></li>
--   <li><a>EDPC W - Intervals</a></li>
--   </ul>
--   
--   TODO: Add <tt>set</tt> <i> <tt>get</tt>, as in
--   [ac-library](https:</i><i>github.com</i>atcoder<i>ac-library</i>blob<i>master</i>atcoder/lazysegtree.hpp)
module Data.SegmentTree.Lazy

-- | Lazy segment tree.
--   
--   <h1>Indices</h1>
--   
--   Use 1-based indices for super handy index hacks:
--   
--   <pre>
--              1             |
--        2           3       | height = 4
--     4     5     6     7    |
--   08 09 10 11 12 13 14 15  v
--   ^
--   +-- nVerts / 2
--   
--   0  1  2  3  4  5  6  7   -- iLeaf is given by user and uses zero-based indices.
--   
--   - parentVertex = vertex / 2 = shiftR vertex 1
--   - leftChild = vertex * 2 = shiftR vertex 1
--   - rightChild = vertex * 2 + 1 = shiftR vertex 1 + 1 = (shiftR vertex 1) .|. 1
--   </pre>
--   
--   <h1>Invariant</h1>
--   
--   <ul>
--   <li>New operators always come from right: <tt>oldOp &lt;&gt;
--   newOp</tt></li>
--   </ul>
data LazySegmentTree v a op s
LazySegmentTree :: !v s a -> !MVector s op -> !Int -> LazySegmentTree v a op s

-- | Creates <a>LazySegmentTree</a> with <a>mempty</a> as the initial
--   accumulated values.
newLazySTree :: forall v a op m. (MVector v a, Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> m (LazySegmentTree v a op (PrimState m))
newLazySTreeV :: forall a op m. (Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> m (LazySegmentTree MVector a op (PrimState m))
newLazySTreeVU :: forall a op m. (Unbox a, Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> m (LazySegmentTree MVector a op (PrimState m))

-- | Creates <a>LazySegmentTree</a> with initial leaf values.
generateLazySTree :: forall v a op m. (MVector v a, Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree v a op (PrimState m))
generateLazySTreeV :: forall a op m. (Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree MVector a op (PrimState m))
generateLazySTreeVU :: forall a op m. (Unbox a, Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree MVector a op (PrimState m))

-- | Appends the lazy operator monoid monoids over some span of the lazy
--   segment tree. These values are just stored and performed over the
--   nodes when queried.
updateLazySTree :: forall v a op m. (MVector v a, Monoid a, MonoidAction op a, Eq op, Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> op -> m ()
queryLazySTree :: forall v a m op. (MVector v a, Monoid a, MonoidAction op a, Eq op, Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> m a

-- | Propagates the lazy operator monoids from top to bottom where the laef
--   vertex is contained.
--   
--   <ul>
--   <li><tt>iLeaf</tt>: Given with zero-based index.</li>
--   </ul>
_propOpMonoidsToLeaf :: (MVector v a, MonoidAction op a, Eq op, Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ()

-- | Evaluates parent values on <tt>updateSegmentTree</tt>. TODO: move to
--   where clause of the update function?
_evalToRoot :: (MVector v a, Monoid a, MonoidAction op a, Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ()


-- | Old adjacency list-based graph module.
--   
--   It's using <tt>Array Int [Int]</tt> as the primary <a>Graph</a> data
--   storage.
module Data.Graph

-- | Adjacency list representation of a graph with node type parameter
--   <tt>a</tt>.
type Graph a = Array Int [a]

-- | Vertex index. Starts with zero.
type Vertex = Int

-- | Weighted <a>Graph</a>. <tt>Entry priority payload</tt>.
type WGraph a = Array Int [Entry a Vertex]

-- | Collects distances from one vertex to every other using BFS, returning
--   a vector.
bfsVec :: Graph Int -> Int -> Vector Int

-- | BFS template for finding a shortest path from one vertex to another.
bfsPath :: Graph Int -> Int -> Int -> Maybe Int

-- | BFS template for collecting shortest paths from one vertex to every
--   other.
bfsVerts :: Graph Int -> Int -> IntMap Int

-- | BFS over grid. Not generalized (yet).
bfsGrid :: UArray (Int, Int) Char -> (Int, Int) -> UArray (Int, Int) Int

-- | Easy 01-BFS
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>ABC 176 D</a></li>
--   </ul>
solve01BFS :: (Int, Int) -> UArray (Int, Int) Char -> UArray (Int, Int) Int

-- | Direction-based 01-BFS:
--   <a>https://atcoder.jp/contests/typical90/tasks/typical90_aq</a>. It's
--   slow, but could be applied easily in certain situations.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typoical 043 - Maze Challenge with Lack of Sleep (★4)</a></li>
--   </ul>
bfsGrid01 :: (Int, Int) -> UArray (Int, Int) Bool -> UArray (Int, Int, Int) Int

-- | DFS where all the reachable vertices from one vertex are collcetd.
components :: Graph Int -> Int -> IntSet

-- | DFS for every path, specially for <a>Typical 072</a>.
dfsEveryPathT072 :: UArray (Int, Int) Char -> (Int, Int) -> Int

-- | Checks a Simple Undirected Graph and returns markings of cycle
--   vertices. TODO: Test if it works as expected.
cyclesSUG :: Array Vertex [Vertex] -> Vector Bool

-- | Dijkstra template that collects all the shortest distances from one
--   vertex to every other. Works for weightened graphs with positive edge
--   capacities only.
--   
--   Pro tip: Use reverse graph to collect cost from every other vertex to
--   one (see <tt>revDjAll</tt>).
dj :: forall a. (Num a, Ord a) => WGraph a -> Int -> IntMap a

-- | Runs Dijkstra's algorithm over a reversed graph of given graph.
revDj :: WGraph Int -> Int -> IntMap Int

-- | Creates a reverse weightened graph.
revWGraph :: WGraph Int -> WGraph Int

-- | Dijkstra backed by a vector.
djVec :: forall a. (Num a, Ord a, Unbox a) => WGraph a -> Int -> a -> Vector a

-- | Runs Dijkstra's algorithm over a reversed graph of given graph.
revDjVec :: WGraph Int -> Int -> Vector Int


-- | Tree folding.
module Data.Tree.Fold

-- | Folds a tree from one root vertex using postorder DFS.
foldTree :: forall m a. Array Vertex [Vertex] -> Vertex -> (m -> a -> a) -> (Vertex -> a) -> (a -> m) -> a

-- | Folds a tree from one root vertex using postorder DFS, recording all
--   the accumulation values on every vertex.
scanTreeVG :: Vector v a => Array Vertex [Vertex] -> Vertex -> (m -> a -> a) -> (Vertex -> a) -> (a -> m) -> v a

-- | Type-restricted <a>scanTreeVG</a>.
scanTreeVU :: Unbox a => Array Vertex [Vertex] -> Vertex -> (m -> a -> a) -> (Vertex -> a) -> (a -> m) -> Vector a

-- | Type-restricted <a>scanTreeVG</a>.
scanTreeV :: Array Vertex [Vertex] -> Vertex -> (m -> a -> a) -> (Vertex -> a) -> (a -> m) -> Vector a

-- | &lt;math&gt;. Folds a tree for every vertex as a root using the
--   rerooting technique. REMARK: <a>mempty</a> is used for initial
--   operator value.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 039 - Tree Distance (★5)</a></li>
--   </ul>
foldTreeAll :: (Unbox a, Unbox m, MonoidAction m a) => Array Vertex [Vertex] -> (Vertex -> a) -> (a -> m) -> Vector a


-- | Maximum flow calculation (Ford-Fulkerson algorithm).
module Data.Graph.MaxFlow

-- | Edge in residual network from on vertex to another.
data RNEdge
RNEdge :: {-# UNPACK #-} !Vertex -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> RNEdge

-- | Points the the other side of the edge
[to] :: RNEdge -> {-# UNPACK #-} !Vertex

-- | Capacity of the edge, or the flow from the vertex to another
[cap] :: RNEdge -> {-# UNPACK #-} !Int

-- | The other side of the vertices is pointed with `rn ! (rev (rn ! to))`
--   so that edge insertion takes just $O(1)$.
[rev] :: RNEdge -> {-# UNPACK #-} !Int

-- | <tt>Vertex -&gt; [RNEdge]</tt>.
--   
--   TODO: For the sub containers, use <tt>Sequence</tt> or something
--   better
type ResidualNetwork = IOVector (IntMap RNEdge)

-- | Builds a residual network at initial state from given edges `(v2,
--   cost)`. {-# INLINE buildRN #-} TODO: make it generic over ST.. for no
--   reason?
buildRN :: Int -> [(Int, (Int, Int))] -> IO ResidualNetwork

-- | Calculates max flow.
maxFlowRN :: Int -> ResidualNetwork -> Int -> Int -> IO Int

-- | Find a flow augment path between two vertices.
augumentPath :: ResidualNetwork -> IOVector Bool -> Vertex -> Int -> IO (Maybe (Int, [(Vertex, Vertex)]))
updateFlow :: ResidualNetwork -> Int -> [(Vertex, Vertex)] -> IO ()
addFlowRNEdge :: ResidualNetwork -> Vertex -> Vertex -> Int -> IO ()
instance GHC.Show.Show Data.Graph.MaxFlow.RNEdge
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Data.Graph.MaxFlow.RNEdge
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Data.Graph.MaxFlow.RNEdge
instance Data.Vector.Unboxed.Base.IsoUnbox Data.Graph.MaxFlow.RNEdge (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
instance Data.Vector.Unboxed.Base.Unbox Data.Graph.MaxFlow.RNEdge


-- | Calculates every shortest path between two vertices (Floyd-Warshall
--   algorithm).
--   
--   <ul>
--   <li>NOTE: It's slow. Prefer Dijkstra when possible.</li>
--   <li>TODO: Faster, general implementation.</li>
--   </ul>
module Data.Graph.FloydWarshall

-- | Create buffer for the Floyd-Warshapp algorithm
newFW :: (PrimMonad m, Unbox cost) => (Vertex -> cost, cost, cost) -> Int -> [(Int, Int)] -> m (MVector (PrimState m) cost)
runFW :: (PrimMonad m, Unbox cost) => (cost -> cost -> cost, cost -> cost -> cost) -> Int -> MVector (PrimState m) cost -> m ()
newFW_ABC286E :: PrimMonad m => (Vertex -> (Int, Int)) -> Int -> [(Int, Int)] -> m (MVector (PrimState m) (Int, Int))
runFW_ABC286E :: PrimMonad m => Int -> MVector (PrimState m) (Int, Int) -> m ()


-- | Digraph coloring.
--   
--   <h1>Typical problems</h1>
--   
--   <ul>
--   <li><a>Typical 026 - Independent Set on a Tree (★ 4)</a></li>
--   </ul>
module Data.Graph.Digraph

-- | Red | Green color
type Color = Bool

-- | Colored vertices in a bipartite graph
type ColorInfo = ([Int], [Int])

-- | DFS with vertices given colors
colorize :: Graph Int -> IntMap Color -> Vertex -> (IntMap Color, Maybe ColorInfo)


-- | Binary lifting is a technique for calculating nth power of a semigroup
--   element in a (big) constant time, or applying them to their semigroup
--   action target.
--   
--   The i-th element of the underlying vector of <a>BinaryLifting</a>
--   stores &lt;math&gt;, with which we can construct any of &lt;math&gt;
--   ((0 &lt;= i &lt; 2^63)) in a big (63) constant time.
module Data.BinaryLifting

-- | Storage of &lt;math&gt;.
newtype BinaryLifting v m
BinaryLifting :: v m -> BinaryLifting v m

-- | Calculates <a>BinaryLifting</a> of the given semigroup
newBinLift :: (Vector v s, Semigroup s) => s -> BinaryLifting v s

-- | Calculates <a>BinaryLifting</a> of the given semigroup
newBinLiftV :: Semigroup s => s -> BinaryLifting Vector s

-- | Calculates <a>BinaryLifting</a> of the given semigroup
newBinLiftVU :: (Semigroup s, Unbox s) => s -> BinaryLifting Vector s

-- | Binarily lifted version of <tt>stimesMonoid</tt>. WARNING: Usually
--   <a>sactBL</a> is much cheaper for semigroup actions with a boxed type.
stimesBL :: (Semigroup s, Vector v s) => BinaryLifting v s -> s -> Int -> s

-- | Binarily lifted version of <tt>stimesMonoid</tt>. WARNING: Usually
--   <a>sactBL</a> is much cheaper for semigroup actions with a boxed type.
mtimesBL :: (Monoid m, Vector v m) => BinaryLifting v m -> Int -> m

-- | Binarily lifted semigroup action application.
sactBL :: (SemigroupAction s a, Vector v s) => BinaryLifting v s -> a -> Int -> a

-- | Alias of <a>sactBL</a> for monoid action.
mactBL :: (MonoidAction m a, Vector v m) => BinaryLifting v m -> a -> Int -> a

-- | Old binary lifting implementation without typeclasses. TODO: Remove
newDoubling :: (Vector v a, Vector v Int) => a -> (a -> a) -> v a

-- | Old binary lifting implementation without typeclasses. TODO: Remove
newDoublingV :: a -> (a -> a) -> Vector a

-- | Old binary lifting implementation without typeclasses. TODO: Remove
applyDoubling :: Vector v op => v op -> a -> (a -> op -> a) -> Int -> a
instance forall k (v :: k -> *) (m :: k). GHC.Classes.Eq (v m) => GHC.Classes.Eq (Data.BinaryLifting.BinaryLifting v m)
instance forall k (v :: k -> *) (m :: k). GHC.Show.Show (v m) => GHC.Show.Show (Data.BinaryLifting.BinaryLifting v m)


-- | TODO, Combine ModInt as Modulo module.
module Math.PowMod
addMod :: Int -> Int -> Int -> Int
subMod :: Int -> Int -> Int -> Int
mulMod :: Int -> Int -> Int -> Int

-- | n! <a>mod</a> m
factMod :: Int -> Int -> Int

-- | One-shot calculation of $base ^ power <a>mod</a> modulo$ in a constant
--   time REMARK: It uses <tt>base <a>mod</a> modulo</tt> in order to avoid
--   overflow.
powModConst :: Int -> Int -> Int -> Int

-- | One-shot calcaulation of &lt;math&gt;, using Fermat's little theorem.
--   
--   &lt;math&gt; where the modulo is a prime number and <tt>x</tt> is not
--   a mulitple of <tt>p</tt>.
invModF :: Int -> Int -> Int

-- | Calculates &lt;math&gt;, using Fermat's little theorem.
divModF :: Int -> Int -> Int -> Int

-- | Cache of &lt;math&gt; for iterative square method.
powModCache :: Int -> Int -> (Int, Vector Int)

-- | Calculates &lt;math&gt; (mod p) from a cache.
powModByCache :: Int -> (Int, Vector Int) -> Int
invModFC :: Int -> (Int, Vector Int) -> Int
divModFC :: Int -> (Int, Vector Int) -> Int

-- | Cache of &lt;math&gt; up to <tt>n</tt>.
factMods :: Int -> Int -> Vector Int

-- | nCr <a>mod</a> m (binominal cofficient).
bcMod :: Int -> Int -> Int -> Int

module Data.Vector.DictOrder
prevPermutationVec :: (Ord e, Vector v e, Vector v (Down e)) => v e -> v e

-- | Returns 1-based dictionary order for the given array. WARNING: Use
--   0-based indices for the input.
dictOrderModuloVec :: Vector v Int => v Int -> Int -> Int


-- | <a>Int</a> with automatic moudlo arithmetic performed. Depends on
--   <tt>Math.PowMod</tt>.
module Data.ModInt

-- | Type level constant <a>Int</a> value. TODO: Replace with
--   <a>KnownNat</a>:
--   <a>https://zenn.dev/mod_poppo/books/haskell-type-level-programming/viewer/ghc-typenats</a>
class TypeInt a
typeInt :: TypeInt a => Proxy a -> Int

-- | <a>Int</a> with automatic moudlo arithmetic performed.
newtype ModInt p
ModInt :: Int -> ModInt p
[getModInt] :: ModInt p -> Int
instance forall k (p :: k). Data.ModInt.TypeInt p => GHC.Real.Real (Data.ModInt.ModInt p)
instance forall k (p :: k). GHC.Show.Show (Data.ModInt.ModInt p)
instance forall k (p :: k). GHC.Read.Read (Data.ModInt.ModInt p)
instance forall k (p :: k). GHC.Classes.Ord (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.Primitive.Types.Prim (Data.ModInt.ModInt p)
instance forall k (p :: k). GHC.Classes.Eq (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.ModInt.TypeInt p => GHC.Num.Num (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.ModInt.TypeInt p => GHC.Real.Fractional (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.ModInt.TypeInt p => GHC.Enum.Enum (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.ModInt.TypeInt p => Data.SemigroupAction.SemigroupAction (Data.Semigroup.Internal.Product (Data.ModInt.ModInt p)) (Data.ModInt.ModInt p)
instance forall k (p :: k). Data.Vector.Unboxed.Base.Unbox (Data.ModInt.ModInt p)


module Math.Matrix

-- | Multiplies HxW matrix to a Hx1 column vector.
mulMatToCol :: (Num e, IArray UArray e) => UArray (Int, Int) e -> [e] -> [e]
mulMatToColMod :: UArray (Int, Int) Int -> Int -> [Int] -> [Int]

-- | Multiplies H1xK matrix to a KxW2 matrix.
mulMat :: (Num e, IArray UArray e) => UArray (Int, Int) e -> UArray (Int, Int) e -> UArray (Int, Int) e

-- | Multiplies H1xK matrix to a KxW2 matrix, getting mod of <tt>m</tt>.
mulMatMod :: Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int

-- | Retruns NxN unit matrix.
unitMat :: Int -> UArray (Int, Int) Int

-- | <a>mulMatMod</a> wrapper for binary lifting.
--   
--   <pre>
--   let !m1 = accumArray @UArray (-) (1 :: Int) ((0, 0), (pred nVerts, pred nVerts)) $ map (,1) removals'
--   let !mn = newBinLiftV $ MulMatMod @MyModulo m1
--   let MulMatMod !mk = stimesBL mn (MulMatMod $ unitMat nVerts) (lenPath)
--   </pre>
newtype MulMatMod p
MulMatMod :: UArray (Int, Int) Int -> MulMatMod p
instance forall k (p :: k). GHC.Show.Show (Math.Matrix.MulMatMod p)
instance forall k (p :: k). GHC.Classes.Eq (Math.Matrix.MulMatMod p)
instance forall k (p :: k). Data.ModInt.TypeInt p => GHC.Base.Semigroup (Math.Matrix.MulMatMod p)
instance forall k (p :: k). Data.ModInt.TypeInt p => Data.SemigroupAction.SemigroupAction (Math.Matrix.MulMatMod p) [GHC.Types.Int]


-- | The rolling hash algorithm lets you create fastly ((O(1))) comparable
--   / concatanatable string slice in after &lt;math&gt; preparation.
--   
--   I suspect if slices longer than the orignal string can be calculated
--   without panic in my implementation.
module Data.RollingHash

-- | Rolling hash of a string.
--   
--   <h1>Internals</h1>
--   
--   Slice (2, 4) of "abcdef" is given as this:
--   
--   <pre>
--              s :=     a       b       c       d       e
--              s4 = b^4 a + b^3 b + b^2 c + b^1 d + b^0 e
--              s2 = b^1 a + b^0 b
--   s4 - s2 * b^3 =                 b^2 c + b^1 d + b^0 e
--   </pre>
data RollingHash b p
RollingHash :: !Int -> !Vector Int -> !Vector Int -> RollingHash b p
[sourceLength] :: RollingHash b p -> !Int

-- | ${B^i mod p}_{i elem [0, n)}$
[dimensions] :: RollingHash b p -> !Vector Int
[hashSum] :: RollingHash b p -> !Vector Int

-- | Type that represents a B-adic number for the rolling hash algorithm.
data HashInt
HashInt :: HashInt

-- | Creates a rolling hash of given string.
newRH :: forall p. TypeInt p => String -> RollingHash HashInt p

-- | Retrieves the original length of the <a>RollingHash</a> string.
lengthRH :: RollingHash b p -> Int

-- | <tt>HashSlice value length</tt>. See also the example of
--   <a>RollingHash</a>.
data HashSlice p
HashSlice :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> HashSlice p
[hashValue] :: HashSlice p -> {-# UNPACK #-} !Int
[hashLength] :: HashSlice p -> {-# UNPACK #-} !Int

-- | Slices a rolling hash string.
sliceRH :: forall b p. TypeInt p => RollingHash b p -> Int -> Int -> HashSlice p

-- | Cons two rolling hash slices.
consHS :: forall b p. TypeInt p => RollingHash b p -> HashSlice p -> HashSlice p -> HashSlice p

-- | Creates an empty rolling hash slice.
emptyHS :: HashSlice p

-- | Concatanates two rolling hash slices.
concatHS :: forall b p t. (TypeInt p, Foldable t) => RollingHash b p -> t (HashSlice p) -> HashSlice p
instance forall k1 (b :: k1) k2 (p :: k2). GHC.Classes.Eq (Data.RollingHash.RollingHash b p)
instance forall k1 (b :: k1) k2 (p :: k2). GHC.Show.Show (Data.RollingHash.RollingHash b p)
instance forall k (p :: k). GHC.Classes.Eq (Data.RollingHash.HashSlice p)
instance forall k (p :: k). GHC.Show.Show (Data.RollingHash.HashSlice p)
instance Data.ModInt.TypeInt Data.RollingHash.HashInt


-- | The Imos's algorithm template for 2D grids.
module Algorithm.Imos

-- | WARNING: Can you really allocate/run &lt;math&gt; algorithm?
imos2D :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int

-- | WARNING: Can you really allocate/run &lt;math&gt; algorithm?
imos2DRev :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int


-- | &lt;math&gt; binary search for sorted items in an inclusive range
--   (from left to right only).
--   
--   <a>bsearch</a> returns an <tt>(ok, ng)</tt> index pair at the
--   boundary. <a>bsearchL</a> and <a>bsearchR</a> returns one of the pair.
--   <a>bsearchM</a> is a monadic variant of <a>bsearch</a>.
--   
--   <h1>Example</h1>
--   
--   With an OK predicate <tt>(&lt;= 5)</tt>, list <tt>[0..9]</tt> can be
--   seen as:
--   
--   <pre>
--   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
--    &lt;--------------&gt;  &lt;--------&gt;
--           ok             ng
--   </pre>
--   
--   In the preceding example, <a>bsearch</a> returns the <tt>(ok, ng)</tt>
--   = <tt>(Just 5, Just 6)</tt> pair at the boundary:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let xs = [0 :: Int .. 9]
--    in bsearch (0 :: Int, 9 :: Int) (\i -&gt; xs !! i &lt;= 5)
--   :}
--   (Just 5,Just 6)
--   </pre>
--   
--   <a>bsearchL</a> returns <tt>Just 5</tt> and <a>bsearchR</a> returns
--   <tt>Just 6</tt>.
module Algorithm.BinarySearch

-- | Pure binary search.
bsearch :: (Int, Int) -> (Int -> Bool) -> (Maybe Int, Maybe Int)

-- | Also known as lower bound.
bsearchL :: (Int, Int) -> (Int -> Bool) -> Maybe Int

-- | Also known as upper bound.
bsearchR :: (Int, Int) -> (Int -> Bool) -> Maybe Int

-- | Monadic binary search.
bsearchM :: forall m. Monad m => (Int, Int) -> (Int -> m Bool) -> m (Maybe Int, Maybe Int)
bsearchML :: forall m. Monad m => (Int, Int) -> (Int -> m Bool) -> m (Maybe Int)
bsearchMR :: forall m. Monad m => (Int, Int) -> (Int -> m Bool) -> m (Maybe Int)
bsearchF32 :: (Float, Float) -> Float -> (Float -> Bool) -> (Maybe Float, Maybe Float)
bsearchF32L :: (Float, Float) -> Float -> (Float -> Bool) -> Maybe Float
bsearchF32R :: (Float, Float) -> Float -> (Float -> Bool) -> Maybe Float
bsearchF64 :: (Double, Double) -> Double -> (Double -> Bool) -> (Maybe Double, Maybe Double)
bsearchF64L :: (Double, Double) -> Double -> (Double -> Bool) -> Maybe Double
bsearchF64R :: (Double, Double) -> Double -> (Double -> Bool) -> Maybe Double

-- | One dimensional index compression: xs -&gt; (nubSorted, indices)
compressList :: [Int] -> (Vector Int, [Int])

-- | Retrieves square root of an <a>Int</a>.
isqrtSlow :: Int -> Int

module Data.Vector.Compress

-- | One dimensional index compression: xs -&gt; (indexer, xs')
compressVU :: Vector Int -> (Vector Int, Vector Int)

module Data.Vector.InvNum

-- | Calculates the inversion number. Be sure to compress the input vector!
invNumVG :: Int -> Vector v Int => v Int -> Int

-- | Calculates the inversion number after applying index compression. It
--   can significantly improve the performance, like in ABC 261 F.
compressInvNumVG :: Vector Int -> Int

module Data.Tree.Lca

-- | Vector for retrieving the parent vertex.
newtype ToParent
ToParent :: Vector Vertex -> ToParent
type LcaCache = (ToParent, Vector Int, BinaryLifting Vector ToParent)

-- | Returns `(parents, depths)` who maps vertices to the corresponding
--   information. REMARK: Use 0-based index for the graph vertices. TODO:
--   Consider using `Maybe Int` instead for easier <a>Monoid</a>
--   integration
treeDepthInfo :: Int -> (Int -> [Int]) -> Int -> (ToParent, Vector Int)

-- | Returns <a>LcaCache</a>, i.e., `(parents, depths, parents')`.
lcaCache :: Int -> (Vertex -> [Vertex]) -> Vertex -> LcaCache

-- | Returns the lowest common ancestor `(v, d)` with the help of the
--   binary lifting technique. REMARK: Use 0-based index for the graph
--   vertices.
lca :: LcaCache -> Int -> Int -> (Int, Int)

-- | Gets the length between given two vertices with the help of LCA.
lcaLen :: LcaCache -> Int -> Int -> Int

-- | <a>ToParent</a> with monoid concatanation.
newtype ToParentM m
ToParentM :: (Int, Vector m) -> ToParentM m

-- | <a>LcaCache</a> with monoid folding on path.
type FoldLcaCache m = (LcaCache, Vector (Vector m))

-- | Returns <a>FoldLcaCache</a> that can be used for calculating the
--   folding value of path between two vertices.
--   
--   <ul>
--   <li>graph: Vertex -&gt; [Vertex]</li>
--   <li>edgeValueOf: child -&gt; parent -&gt; m</li>
--   </ul>
foldLcaCache :: forall m. (Monoid m, Unbox m) => Int -> (Vertex -> [Vertex]) -> Vertex -> (Vertex -> Vertex -> m) -> FoldLcaCache m

-- | <a>foldLcaCache</a> specific for `Array Vertex [(Vertex, a)]`.
foldLcaCache2 :: forall a m. (Monoid m, Unbox m) => Array Int [(Vertex, a)] -> (a -> m) -> FoldLcaCache m

-- | Calculates the folding value of the path between two vertices in a
--   tree.
foldViaLca :: forall m. (Monoid m, Unbox m) => FoldLcaCache m -> Int -> Int -> m
instance GHC.Base.Semigroup Data.Tree.Lca.ToParent
instance Data.SemigroupAction.SemigroupAction Data.Tree.Lca.ToParent Data.Graph.Vertex


-- | <tt>vector</tt>-based sparse graph implementation (weightened or
--   unweightened).
--   
--   Heavily inspired by <tt>cojna/iota</tt>.
module Data.SparseGraph
type Edge = (Vertex, Vertex)

-- | Weightened edge
type WEdgeWith w = (Vertex, Vertex, w)
type EdgeId = Int

-- | CSR (compressed sparse row) representation of a graph (weightened or
--   unweightened)
data SparseGraph i w
SparseGraph :: !(i, i) -> !Int -> !Int -> !Vector Int -> !Vector Vertex -> !Vector w -> SparseGraph i w

-- | Vertex index boundary.
[boundsSG] :: SparseGraph i w -> !(i, i)

-- | Number of vertices.
[nVertsSG] :: SparseGraph i w -> !Int

-- | Number of edges.
[nEdgesSG] :: SparseGraph i w -> !Int

-- | Maps <tt>Vector</tt> to the starting edge index.
[offsetsSG] :: SparseGraph i w -> !Vector Int

-- | Adjacent vertices sorted with starting vertex.
[adjacentsSG] :: SparseGraph i w -> !Vector Vertex

-- | Edge weight information.
[edgeWeightsSG] :: SparseGraph i w -> !Vector w

-- | Builds an unweightned <a>SparseGraph</a>.
--   
--   TODO: Faster implementation
buildUSG :: Unindex i => (i, i) -> Vector (i, i) -> SparseGraph i ()

-- | Builds a weightned <a>SparseGraph</a>.
buildWSG :: (Unindex i, Unbox w) => (i, i) -> Vector (i, i, w) -> SparseGraph i w
buildRawSG :: (Unindex i, Unbox w) => (i, i) -> Vector (Vertex, Vertex, w) -> SparseGraph i w

-- | Retrieves adjacent vertices.
adj :: SparseGraph i w -> Vertex -> Vector Vertex

-- | Returns <tt>(EdgeId, Vertex)</tt> paris. Hardly used.
eAdj :: SparseGraph i w -> Vertex -> Vector (EdgeId, Vertex)

-- | Retrieves adjacent vertex indices.
adjIx :: Unindex i => SparseGraph i w -> i -> Vector i

-- | Retrieves adjacent vertices with weights.
adjW :: Unbox w => SparseGraph i w -> Vertex -> Vector (Vertex, w)

-- | Retrieves adjacent vertex indices with weights.
adjWIx :: (Unindex i, Unbox w) => SparseGraph i w -> i -> Vector (i, w)
dfsSG :: Unindex i => SparseGraph i w -> i -> IxVector i (Vector Int)

-- | Just a template. Typical problem: <a>ABC 317 C - Remembering the
--   Days</a>
dfsEveryPathSG :: SparseGraph Int Int -> Int -> Int

-- | Also consider using union-find tree.
componentsVecSG :: Ix i => SparseGraph i w -> i -> IxVector i (Vector Bool)

-- | <i>O(V+E)</i> breadth-first search. Unreachable vertices have length
--   of <tt>-1</tt>.
bfsSG :: (Show i, Unindex i) => SparseGraph i w -> i -> IxVector i (Vector Int)
bfsGrid317E_MBuffer :: IxUVector (Int, Int) Bool -> (Int, Int) -> IxUVector (Int, Int) Int

-- | Dijkstra: $O((E+V) log {V})$
djSG :: forall i w. (Unindex i, Num w, Ord w, Unbox w) => SparseGraph i w -> w -> i -> Vector w

-- | Returns a list of a route in reverse order (a route from end to
--   start).
dfsPathSG :: Unindex i => SparseGraph i w -> i -> i -> Maybe [Edge]

-- | Returns a list of a route in reverse order (a route from end to
--   start).
treeDfsPathSG :: Unindex i => SparseGraph i w -> i -> i -> [Edge]

-- | Topological sort
--   
--   Non-referenced vertices come first: &gt;&gt;&gt; let !gr = buildUSG
--   ((0, 4) :: (Int, Int)) $ VU.fromList ([(0, 1), (0, 2), (2, 3)] ::
--   [(Int, Int)]) &gt;&gt;&gt; topSortSG gr [4,0,2,3,1]
topSortSG :: SparseGraph i w -> [Vertex]

-- | Partial running of <tt>scc</tt> over topologically sorted vertices,
--   but for some connected components only.
topScc1SG :: forall i w m. PrimMonad m => SparseGraph i w -> MVector (PrimState m) Bool -> Vertex -> m [Vertex]

-- | Creates a reverse graph. TODO: return weightned graph
revSG :: (Unindex i, Unbox w) => SparseGraph i w -> SparseGraph i w

-- | Collectes strongly connected components, topologically sorted.
--   Upstream vertices come first, e.g., <tt>(v1 - v2) -&gt; v3 -&gt;
--   v4</tt>.
topSccSG :: (Unindex i, Unbox w) => SparseGraph i w -> [[Int]]

-- | LCA component. See also <tt>lca</tt> and <tt>lcaLen</tt> from
--   <a>Tree</a>.
treeDepthInfoSG :: SparseGraph Int w -> Int -> (ToParent, Vector Int)

-- | LCA component. Returns <a>LcaCache</a>, i.e., `(parents, depths,
--   parents')`.
lcaCacheSG :: SparseGraph Int w -> Vertex -> LcaCache
instance (GHC.Show.Show i, GHC.Show.Show w, Data.Vector.Unboxed.Base.Unbox w) => GHC.Show.Show (Data.SparseGraph.SparseGraph i w)
